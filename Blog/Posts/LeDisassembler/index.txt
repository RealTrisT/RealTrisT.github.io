
[__TITLE__][<~Project: LeDisassembler~>]

[h20][<~What~>]

A disassembler, that is fully modular and displays as much data as possible.


[h20][<~Why~>]

I've needed to make a disassembler for a while now, because of multiple projects that I've worked on where one would have come in quite handy. (for example the section extender, that had to become a section appender)

There's already capstone and shit, but I want to learn as much as possible about the x86 architecture because it genuinely interests me, and what better way of doing that than coding a disassembler.

With the power of a disassembler I coded myself, I will become a god of the binary.


[h20][<~Resauce~>]

[__LINK="https://software.intel.com/sites/default/files/managed/ad/01/253666-sdm-vol-2a.pdf"][<~The intel docs on x86 (2A), the part that matters.~>]


[h20][<~It.~>]


So this is important since this is how an instruction works.

[img src="https://imgur.com/Iqvwqk1.png"]

I've sorta read on this a bit before, and I remember there were a fixed set of instruction prefixes, so might start from there.

Got 600 pages to read, so ye.

Right so first things first, how the thing's gonna be.
I'm thinking making a structure and having some flags to indicate the operands, variable for size etc..
Generally just all the useful information so one is able to get the original opcode from the struct, as well as useful info.

So. ``Opcode.h`` is on it's way.

Since I'm not just making a size calculator I think I might make private members for instruction prefixes, opcode, modR/M, etc..




[h6][<~Instruction prefixes~>]


So instruction prefixes are 1 byte each, and multiple can be used, so I think Imma make it a flag.

There are 4 groups:
-Lock/Repeat
-Segment Override
-Operand-size Override
-Address-Size Override

The last 2 are just one thing each, 0x66 or 0x67 respectively. Somewhat self explanatory.
The first two aren't so simple, with different prefixes for different situations, and different uses for the same prefix depending on context.

More info on this is on page 36, I'd advise skipping the bulletpoints.



[h6][<~Opcodes~>]

Oh boy, this is the hadpat.

The main takeaway is this: ```txt
A primary opcode can be 1, 2, or 3 bytes in length. An additional 3-bit opcode field is sometimes encoded in the ModR/M byte.
```
Two-byte opcode formats for general-purpose and SIMD (Single instruction, multiple data) instructions consist of a 0x0F (as an escape code, not to be confused with LOCK prefix's 0xF0) and an second opcode byte, and "optionally" a mandatory prefix in the beginning of all that.
[h2][<~"optionally" cuz it has to be there for some opcodes, and not for others~>]

Three-byte opcodes for general-purpose and SIMD instructions are basically the same but instead of one additional opcode byte, it has two.

So basically we know that if second byte is 0x0F, chances are the first is a mandatory prefix.

Tho honestly, I'd advise reading 2.1.2, it's highly informative. But read it real slow, you get 1 letter or 1 comma worng and you'll be confused senseless. Or maybe it's just me.



[h6][<~Opcodes~>]

```txt
Many instructions that refer to an operand in memory have an addressing-form specifier byte (called the ModR/M byte) following the primary opcode.
```