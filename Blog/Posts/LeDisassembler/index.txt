
[__TITLE__][<~Project: LeDisassembler~>]

[h20][<~What~>]

A disassembler, that is fully modular and displays as much data as possible.


[h20][<~Why~>]

I've needed to make a disassembler for a while now, because of multiple projects that I've worked on where one would have come in quite handy. (for example the section extender, that had to become a section appender)

There's already capstone and shit, but I want to learn as much as possible about the x86 architecture because it genuinely interests me, and what better way of doing that than coding a disassembler.

With the power of a disassembler I coded myself, I will become a god of the binary.


[h20][<~Resauce~>]

[__LINK="https://software.intel.com/sites/default/files/managed/ad/01/253666-sdm-vol-2a.pdf"][<~The intel docs on x86 (2A), the part that matters.~>]


[h20][<~It.~>]


So this is important since this is how an instruction works.

[img src="https://imgur.com/Iqvwqk1.png"]

I've sorta read on this a bit before, and I remember there were a fixed set of instruction prefixes, so might start from there.

Got 600 pages to read, so ye.

Right so first things first, how the thing's gonna be.
I'm thinking making a structure and having some flags to indicate the operands, variable for size etc..
Generally just all the useful information so one is able to get the original opcode from the struct, as well as useful info.

So. ``Opcode.h`` is on it's way.

Since I'm not just making a size calculator I think I might make private members for instruction prefixes, opcode, modR/M, etc..




[h6][<~Instruction prefixes~>]


So instruction prefixes are 1 byte each, and multiple can be used, so I think Imma make it a flag.

There are 4 groups:
-Lock/Repeat
-Segment Override
-Operand-size Override
-Address-Size Override

The last 2 are just one thing each, 0x66 or 0x67 respectively. Somewhat self explanatory.
The first two aren't so simple, with different prefixes for different situations, and different uses for the same prefix depending on context.

More info on this is on page 36, I'd advise skipping the bulletpoints.



[h6][<~Opcodes~>]

Oh boy, this is the hadpat.

The main takeaway is this: ```txt
A primary opcode can be 1, 2, or 3 bytes in length. An additional 3-bit opcode field is sometimes encoded in the ModR/M byte.
```
Two-byte opcode formats for general-purpose and SIMD (Single instruction, multiple data) instructions consist of a 0x0F (an escape code as the primary opcode, not to be confused with LOCK prefix's 0xF0) and an second opcode byte, and "optionally" a mandatory prefix in the beginning of all that (0x66, 0xF2 or 0xF3).
[h2][<~"optionally" cuz it has to be there for some opcodes, and not for others~>]

Three-byte opcodes for general-purpose and SIMD instructions are basically the same but instead of one additional opcode byte, it has two.

So basically we know that if second byte is 0x0F, chances are the first is a mandatory prefix.

Tho honestly, I'd advise reading 2.1.2, it's highly informative. But read it real slow, you get 1 letter or 1 comma wrong and you'll be confused senseless. Or maybe it's just me.



[h6][<~ModR/M~>]

So the main takeaway is this:
```txt
Many instructions that refer to an operand in memory have an addressing-form specifier byte (called the ModR/M byte) following the primary opcode.
```
Let's first start by reminding ourselves of the pic above.

It was highly useful for me, since back when I tried looking into this the first time, the ModR/M byte was a complete monster to me, that I really couldn't understand.

Bot now it's broken down([h2][<~aren't monospace fonts great~>]):
```txt
  7 6    5   4   3   2 0
| Mod | Reg/Opcode | R/M |
```
This is the 2.1.3 section, and I really don't think I can explain it any better than it is.

The mod and r/m fields come together to form 32 possible values (2^(power of)5 = 32), that is 8 registers, and 24 addressing modes.

The reg/opcode, is exactly that. Either a register, or the rest of the opcode information. That is determined by the primary opcode itself.

The r/m field can specify a register as an operand or along with the mod field, it can be an addressing mode. Sometimes, it's combination with the mod field is used to express opcode info for some instructions. Dunno.



[h6][<~SIB~>]

Some encodings of the ModR/M byte require the extra addressing byte SIB.

For example the base-plus-index and scale-plus-index forms of 32-bit addressing require the SIB.

SIB has the fields scale, index, and base.



[h6][<~Displacement/Immediate~>]

```txt
Some addressing forms include a displacement immediately following the ModR/M byte (or the SIB byte if one is
present). If a displacement is required, it can be 1, 2, or 4 bytes.
If an instruction specifies an immediate operand, the operand always follows any displacement bytes. An immediate
operand can be 1, 2 or 4 bytes.
```
Basically displacement is relative address and immediate is value (I think rn, might be wrong).



[h6][<~Addressing-Mode Encoding of ModR/M and SIB Bytes~>]

So this is a massive shit-tone of text, give me a sec. xd.

Ok, so the main takeaway are these tables:
[img src="https://imgur.com/8DsvAXZ.png"]
[img src="https://imgur.com/ueZuW61.png"]
[img src="https://imgur.com/DPOtyhM.png"]

There are 3 tables, first for 16-bit addressing, second for 32, and third for SID stuff.

Provided we're in 32, the first table will only come in handy when the opcode is preceeded by the Address-Size Override prefix.


[h5][<~Example:~>]

Opcode ``67 89 10``

67: Address-Size Override prefix
89: Opcode mov(where the 2nd operand is the default addressing mode (32 in this case))
10: ModR/M, that if we check on the table, we can see first operand is [bx+si], and second el/ex/edx. Which it is gonna depend on the opcode.

Now if we check an [__LINK="http://ref.x86asm.net/coder32.html"][<~opcode table~>]:
[img src="https://imgur.com/jJvrh7y.png"]

We'll see that the second operand is a register, either 16 or 32, and since default addressing mode is 32, we'll get edx.

The first operand doesn't matter since we've already got everything from ModR/M, so finally, we get:

``mov [bx+si], edx``


[h5][<~Example 2:~>]

Opcode ``67 66 89 10``

It's basically the same as the previous example, but has that 66 there.
That changes the addressing mode, and since current is 32, it'll become 16.
So, the 16 bit variant of edx is dx.

So since that's the only difference, and as we saw in the last image, the second operand depended on the addressing mode, we should this time get:

``mov [bx+si], dx``